/*
    Copyright (c) 2011, Jun Namikawa <jnamika@gmail.com>

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted, provided that the above
    copyright notice and this permission notice appear in all copies.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H    //ifdef: to prevent same name of head file existing in differnet file 
#include "config.h"     //make both of them(different file) can be compiled
#endif

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>
#ifdef ENABLE_MTRACE
#include <mcheck.h>
#endif

#include "utils.h"     //putting head file can use the function in that file and even giving new definition
#include "main.h"
#include "rnn_runner.h"


#define TO_STRING_I(s) #s
#define TO_STRING(s) TO_STRING_I(s)

static void display_help (void)
{
  //puts: showing the words
  //the difference between "puts" and "printf" is that "puts" can only show the string but can't show the variable
  //the other difference is that "puts" can turn to next row automatically
    puts("rnn-generate  - a program to display output of recurrent neural "
            "networks");
    puts("");
    puts("Usage: rnn-generate [-s seed] [-n length] [-i index] [-c] [-a] "
            "rnn-file");
    puts("Usage: rnn-generate [-v] [-h]");
    puts("");
    puts("Available options are:");
    puts("-s seed");
    puts("    `seed' is the seed for the initialization of random number "
            "generator, which specifies a starting point for the random number "
            "sequence, and provides for restarting at the same point. If this "
            "option is omitted, the current system time is used.");
    puts("-n length");
    puts("    Number of iterations to generate output of a network. "
            "Default is " TO_STRING(LENGTH) ".");
    puts("-i index");
    puts("    Index of an initial state corresponding to a training example. "
            "Default is " TO_STRING(INDEX) " (use a random initial state).");
    puts("-r reg_state_size");
    puts("    Number of input state size that receives externally given input values. "
            "Default is " TO_STRING(REG_STATE_SIZE) " (totally closed-loop generation).");
    puts("-c");
    puts("    Displays context states instead of output.");
    puts("-a");
    puts("    Displays output and context states.");
    puts("-v");
    puts("    Prints the version information and exit.");
    puts("-h");
    puts("    Prints this help and exit.");
    puts("");
    puts("Program execution:");
    puts("First, rnn-generate reads the rnn-file (ex: rnn.dat) generated by "
            "rnn-learn in order to setup model parameters. Next, it displays "
            "output of a network up to given length with respect to the "
            "initial state corresponding to given index.");
}

static void display_version (void)
{
    printf("rnn-generate version %s\n", TO_STRING(VERSION));
}

static void display_rnn_state (
        struct rnn_runner *runner,
	struct rnn_state *rnn_s,
        long length,
        int mode,
	int reg_state_size)
{
    const int out_state_size = rnn_out_state_size_from_runner(runner);
    const int c_state_size = rnn_c_state_size_from_runner(runner);
    struct rnn_state *rnn_s_from_runner = runner->rnn.rnn_s + runner->id;

    for (long n = 0; n < length; n++) {
		if (rnn_s != NULL) {
			if (n < rnn_s->length) {
				for (int i = out_state_size - reg_state_size; i < out_state_size; i++) {
					rnn_s_from_runner->in_state[0][i] = rnn_s->in_state[n][i];
				}
				memmove(rnn_s_from_runner->teach_state[0], rnn_s->teach_state[n], sizeof(double) * 
						out_state_size);
			} else {
				for (int i = 0; i < out_state_size; i++) {
					rnn_s_from_runner->teach_state[0][i] = 0;
				}
			}
		} else {
			for (int i = 0; i < out_state_size; i++) {
				rnn_s_from_runner->teach_state[0][i] = 0;
			}
		}
		update_rnn_runner(runner);   //in common/rnn_runner
		                             //contents of update_rnn_runner:  rnn_fmap(runner->rnn.rnn_s + runner->id)
        if (mode == 0) {
            double *out_state = rnn_out_state_from_runner(runner);
            double *var_state = rnn_var_state_from_runner(runner);
            printf("%f\t%f", out_state[0], var_state[0]);
            for (int i = 1; i < out_state_size; i++) {
                printf("\t%f\t%f", out_state[i], var_state[i]);
            }
            printf("\n");
        } else if (mode == 1) {
            double *c_inter_state = rnn_c_inter_state_from_runner(runner);
            printf("%f", c_inter_state[0]);
            for (int i = 1; i < c_state_size; i++) {
                printf("\t%f", c_inter_state[i]);
            }
            printf("\n");
        } else if (mode == 2) {
			double *teach_state = rnn_teach_state_from_runner(runner);
            double *out_state = rnn_out_state_from_runner(runner);
            double *var_state = rnn_var_state_from_runner(runner);
            double *c_inter_state = rnn_c_inter_state_from_runner(runner);
            printf("%ld\t", n);
            for (int i = 0; i < out_state_size; i++) {
                printf("\t%f\t%f\t%f", teach_state[i], out_state[i], var_state[i]);
            }
            for (int i = 0; i < c_state_size; i++) {
                printf("\t%f", c_inter_state[i]);
            }
            printf("\n");
        }
    }
}

int main (int argc, char *argv[])
{
#ifdef ENABLE_MTRACE
    mtrace();
#endif
    unsigned long seed;      //the range of "unsigned" is from 0 ~ 2^n --- all are non-negative number
    long length = LENGTH;    //the total range of long is 2^32 but because without unsigned, it will start from -(2^32)/2 ~ (2^32)/2
    int index = INDEX;
    int reg_state_size = REG_STATE_SIZE;
    int mode = 0;

    // 0 < seed < 4294967296
    seed = (((unsigned long)(time(NULL) * getpid())) % 4294967295) + 1;      //getpid: know the process ID (non-negative)

    int opt;
    while ((opt = getopt(argc, argv, "s:n:i:r:cavh")) != -1) {
        switch (opt) {
            case 's':
                seed = strtoul(optarg, NULL, 0);
                break;
            case 'n':
                length = atol(optarg);
                break;
            case 'i':
                index = atoi(optarg);
                break;
            case 'r':
                reg_state_size = atoi(optarg);
                break;
            case 'c':
                mode = 1;
                break;
            case 'a':
                mode = 2;
                break;
            case 'v':
                display_version();
                exit(EXIT_SUCCESS);
            case 'h':
                display_help();
                exit(EXIT_SUCCESS);
            default: /* '?' */
                fprintf(stderr, "Try `rnn-generate -h' for more "
                        "information.\n");
                exit(EXIT_SUCCESS);
        }
    }
    if (seed <= 0) {
        print_error_msg("seed for random number generator not in valid "
                "range: x >= 1 (integer)");
        exit(EXIT_FAILURE);
    }
    if (reg_state_size < 0) {
        print_error_msg("reg_state_size for number of input state size "
						"that receives externally given input values not in valid "
                "range: x >= 0 (integer)");
        exit(EXIT_FAILURE);
    }
    if (optind >= argc) {
        print_error_msg("Usage: rnn-generate [-s seed] [-n length] [-i index] "
                "rnn-file\nTry `rnn-generate -h' for more information.");
        exit(EXIT_SUCCESS);
    }

    init_genrand(seed);

    struct rnn_runner runner;
    FILE *fp;
    if ((fp = fopen(argv[optind], "r")) == NULL) {
        print_error_msg("cannot open %s", argv[optind]);
        exit(EXIT_FAILURE);
    }
    init_rnn_runner(&runner, fp);  //in common/rnn_runner.c
    fclose(fp);

    set_init_state_of_rnn_runner(&runner, index);
    if (index >= 0 && index < runner.id) {
		display_rnn_state(&runner, runner.rnn.rnn_s + index, length, mode, reg_state_size);
	} else {
		display_rnn_state(&runner, NULL, length, mode, reg_state_size);
    }
    free_rnn_runner(&runner);

#ifdef ENABLE_MTRACE
    muntrace();
#endif
    return EXIT_SUCCESS;
}

